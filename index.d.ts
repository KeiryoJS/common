// Generated by dts-bundle v0.7.3

export class Mutex {
  get locked(): boolean;

  /**
   * Blocks the event loop for an x amount of milliseconds.
   *
   * @param duration How long to block the event loop.
   */
  static wait(duration: number): Promise<void>;

  take(): Promise<Release>;

  cancel(): void;
}

type Release = () => void;

export class Extender<M extends Dictionary<Class>> {
  readonly structures: Map<keyof M, Class<any>>;

  /**
   * @param map The structure map.
   */
  constructor(map: M);

  /**
   * Returns a structure that's assigned to the provided key.
   *
   * @param key Structure's key.
   */
  get<K extends keyof M>(key: K): M[K];

  /**
   * Used to extend an existing structure.
   *
   * @param key Key of the structure to extend.
   * @param extender The extender
   */
  extend<K extends keyof M, E extends M[K]>(key: K, extender: (base: M[K]) => E): Extender<M>;
}

export class Snowflake {
  /**
   * Transforms an ID into binary.
   *
   * @param snowflake The ID to transform.
   */
  static toBinary(snowflake: snowflake): string;

  /**
   * Transforms an ID from binary to a decimal string.
   *
   * @param binary The binary string to be transformed.
   */
  static fromBinary(binary: string): snowflake;

  /**
   * Deconstructs a Discord Snowflake.
   *
   * @param snowflake The snowflake to deconstruct.
   * @param epoch The epoch to use when deconstructing.
   */
  static deconstruct(snowflake: snowflake, epoch?: number): DeconstructedSnowflake;

  /**
   * Generates a new snowflake.
   *
   * @param options The options to use when generating a snowflake.
   */
  static generate({ epoch, timestamp }?: GenerateSnowflakeOptions): snowflake;
}

/**
 * A Twitter snowflake, except the default epoch is 2015-01-01T00:00:00.000Z
 *
 * ```
 * If we have a snowflake '266241948824764416' we can represent it as binary:
 *
 * 64                                          22     17     12          0
 *  000000111011000111100001101001000101000000  00001  00000  000000000000
 *           number of ms since epoch           worker  pid    increment
 * ```
 */
export type snowflake = string;

export interface GenerateSnowflakeOptions {
  timestamp?: Date | number;
  epoch?: Date | number;
}

export interface DeconstructedSnowflake {
  binary: string;
  timestamp: number;
  workerId: number;
  processId: number;
  increment: number;
}

export class Collection<K, V> extends Map<K, V> {
  ["constructor"]: typeof Collection;

  /**
   * Creates a collection from an array of values and the keys are the indexes.
   *
   * @param {Array} values The array of values.
   * @returns {Collection}
   */
  static from<V>(values: V[]): Collection<number, V>;
  /**
   *
   * Creates a collection from an array of tuples or object.
   *
   * @param {Tuple[] | Dictionary} tupleArrayOrObject The tuple array or dictionary.
   * @returns {Collection}
   */
  static from<K, V>(tupleArrayOrObject: Tuple<K, V>[] | Dictionary<V>): Collection<K, V>;

  /**
   * Returns the first key in this collection.
   *
   * @returns {?any}
   */
  first(): Tuple<K, V> | null;
  /**
   * Returns an array of keys at the start of this collection.
   *
   * @param {number} amount The amount of values.
   * @returns {any[]}
   */
  first(amount: number): Tuple<K, V>[];

  /**
   * Returns the last key in this collection.
   *
   * @returns {?any}
   */
  last(): Tuple<K, V> | null;
  /**
   *
   * Returns an array of keys at the end of this collection.
   * @param {number} amount The amount of values.
   * @returns {any[]}
   */
  last(amount: number): Tuple<K, V>[];

  /**
   * Get an array of all values in this collection.
   * @returns {any[]}
   */
  array(): V[];

  /**
   * Tests whether or not an entry in this collection meets the provided predicate.
   *
   * @param {function} predicate A predicate that tests all entries.
   * @param {any} [thisArg] An optional binding for the predicate function.
   * @returns {boolean}
   */
  some(predicate: (value: V, key: K, col: this) => unknown, thisArg?: unknown): boolean;

  /**
   * Creates a new collection with the items within the provided range.
   *
   * @param {number} [from] Where to stop.
   * @param {number} [end] Where to end.
   * @returns {Collection}
   */
  slice(from?: number, end?: number): Collection<K, V>;

  /**
   * Collection#forEach but it returns the collection instead of nothing.
   *
   * @param {function} fn The function to be ran on all entries.
   * @param {any} [thisArg] An optional binding for the fn parameter.
   * @returns {Collection}
   */
  each(fn: (value: V, key: K, col: this) => unknown, thisArg?: unknown): this;

  /**
   * Computes a value if it's absent in this collection.
   * @param {any} key The key.
   * @param {any} value The value to use if nothing is found.
   * @returns {any}
   */
  ensure(key: K, value: ((key: K) => V) | V): V;

  /**
   * Get a random value from this collection.
   *
   * @returns {any}
   */
  random(): V;

  /**
   * Get a random key from this collection.
   *
   * @returns {any}
   */
  randomKey(): K;

  /**
   * Get random entry from this collection.
   *
   * @returns {Tuple}
   */
  randomEntry(): Tuple<K, V>;

  /**
   * Sweeps entries from the collection.
   *
   * @param {function} fn The predicate.
   * @param {any} [thisArg] Optional binding for the predicate.
   * @returns {number}
   */
  sweep(fn: (value: V, key: K, col: this) => boolean, thisArg?: unknown): number;

  /**
   * Finds a value using a predicate from this collection
   *
   * @param {function} fn Function used to find the value.
   * @param {any} [thisArg] Optional binding to use.
   * @returns {?any}
   */
  find(fn: (value: V, key: K, col: this) => boolean, thisArg?: unknown): V | null;

  /**
   * Reduces this collection down into a single value.
   *
   * @param {function} fn The function used to reduce this collection.
   * @param {any} acc The accumulator.
   * @param {any} [thisArg] Optional binding for the reducer function.
   * @returns {any}
   */
  reduce<A>(fn: (acc: A, value: V, key: K, col: this) => A, acc: A, thisArg?: unknown): A;

  /**
   * Partition this collection. First collection are the entries that returned true, second collection are the entries that returned false.
   *
   * @param {function} predicate The predicate function.
   * @param {any} [thisArg] Optional binding for the predicate.
   * @returns {[Collection, Collection]}
   */
  partition(predicate: (value: V, key: K, col: this) => boolean, thisArg?: unknown): Tuple<Collection<K, V>, Collection<K, V>>;

  /**
   * Returns a filtered collection based on the provided predicate.
   *
   * @param {function} fn The predicate used to determine whether or not an entry can be passed to the new collection.
   * @param {any} [thisArg] Optional binding for the predicate.
   * @returns {Collection}
   */
  filter(fn: (value: V, key: K, col: this) => boolean, thisArg?: unknown): Collection<K, V>;

  /**
   * Maps this collection into an array. Array#map equivalent.
   *
   * @param {function} fn Function used to map values to an array.
   * @param {any} [thisArg] Optional binding for the map function.
   * @returns {any[]}
   */
  map<T>(fn: (value: V, key: K, col: this) => T, thisArg?: unknown): T[];

  /**
   * Sorts the entries in-place in this collection.
   *
   * @param {function} compareFunction Function to determine how this collection should be sorted.
   * @returns {Collection}
   */
  sort(compareFunction?: (firstValue: V, secondValue: V, firstKey?: K, secondKey?: K) => number): this;

  /**
   * Sorts entries in a new collection
   *
   * @param {function} compareFunction Function to determine how the resulting collection should be sorted
   * @returns {Collection}
   */
  sorted(compareFunction?: (firstValue: V, secondValue: V, firstKey?: K, secondKey?: K) => number): Collection<K, V>;

  /**
   * Returns a clone of this collection.
   *
   * @returns {Collection}
   */
  clone(): Collection<K, V>;

  /**
   * Get the string representation of this collection.
   *
   * @returns {string}
   */
  toString(): string;
}

export type Tuple<A = any, B = any> = [ A, B ];
export type Dictionary<V = any, K extends PropertyKey = string> = Record<K, V>;
export type Class<T = any> = {
  new(...args: any[]): T;
};

export namespace Scheduled {
  /**
   * All scheduled intervals.
   */
  const INTERVALS: Set<NodeJS.Timeout>;
  /**
   * All scheduled timeouts.
   */
  const TIMEOUTS: Set<NodeJS.Timeout>;
}

/**
 * Creates a new {@see Interval}
 *
 * @param delay Delay between each execution
 * @param block The block to execute
 * @param args Arguments to pass
 */
export function createInterval(delay: number, block: Task, ...args: any[]): Interval;

/**
 * Creates a new {@see Timeout}
 *
 * @param delay Delay until execution
 * @param block The block to execute.
 * @param args Arguments to pass.
 */
export function createTimeout(delay: number, block: Task, ...args: any[]): Timeout;

export class Interval extends TaskScheduler {
  /**
   * Starts executing the configured task every `delay` milliseconds
   *
   * @param delay The delay between each execution.
   * @param args The arguments to pass.
   */
  start(delay: number, ...args: any[]): Interval;

  /**
   * Disposes of this interval.
   */
  dispose(): void;
}

export class Timeout extends TaskScheduler {
  /**
   * Executes the configured task in x milliseconds..
   *
   * @param delay The amount of time to wait.
   * @param args The arguments to pass.
   */
  start(delay: number, ...args: any[]): Timeout;

  /**
   * Disposes of this Timeout.
   */
  dispose(): void;
}

/**
 * Determines whether a value in an object.
 *
 * @param input The value to test
 */
export function isObject(input: unknown): input is Dictionary;

/**
 * Merges objects into one.
 *
 * @param {Dictionary} objects The objects to merge.
 */
export function mergeObject<O extends Record<PropertyKey, any> = Record<PropertyKey, any>>(...objects: Partial<O>[]): O;

/**
 * Used when the library is unsure whether a package has been installed.
 *
 * @param name The package name.
 */
export function safeRequire<T>(name: string): T | undefined;

export abstract class TaskScheduler {
  /**
   * The NodeJS timeout ref.
   */
  ref?: NodeJS.Timeout;
  /**
   * The provided task to execute.
   * @protected
   */
  protected _task: Task;

  /**
   * @param task The provided task.
   */
  constructor(task: Task);

  /**
   * Start's this scheduled task.
   *
   * @param delay The delay in which to execute this task.
   * @param args The arguments to pass.
   */
  abstract start(delay: number, ...args: any[]): TaskScheduler;

  /**
   * Cancels this Scheduled task.
   */
  abstract dispose(): void;
}

export type Task = (...args: any[]) => void;

