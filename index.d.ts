// Generated by dts-bundle v0.7.3

import "./prototypes";

declare global {
  interface Array<T> {
    /**
     * Whether this array is empty, uses {@link Array#size} to determine the returned value.
     */
    isEmpty: boolean;

    /**
     * Removes the first element that matches {@param value}
     *
     * @param value The value to remove.
     *
     * @returns T or undefined
     */
    removeFirst(value: T): T | undefined;
  }
}

export class Mutex {
  get locked(): boolean;

  /**
   * Blocks the event loop for an x amount of milliseconds.
   *
   * @param duration How long to block the event loop.
   */
  static wait(duration: number): Promise<void>;

  take(): Promise<Release>;

  cancel(): void;
}

type Release = () => void;

export class Extender<M extends Dictionary<Class>> {
  readonly structures: Map<keyof M, Class<any>>;

  /**
   * @param map The structure map.
   */
  constructor(map: M);

  /**
   * Returns a structure that's assigned to the provided key.
   *
   * @param key Structure's key.
   */
  get<K extends keyof M>(key: K): M[K];

  /**
   * Used to extend an existing structure.
   *
   * @param key Key of the structure to extend.
   * @param extender The extender
   */
  extend<K extends keyof M, E extends M[K]>(key: K, extender: (base: M[K]) => E): Extender<M>;
}

export class Snowflake {
  /**
   * Transforms an ID into binary.
   *
   * @param snowflake The ID to transform.
   */
  static toBinary(snowflake: snowflake): string;

  /**
   * Transforms an ID from binary to a decimal string.
   *
   * @param binary The binary string to be transformed.
   */
  static fromBinary(binary: string): snowflake;

  /**
   * Deconstructs a Discord Snowflake.
   *
   * @param snowflake The snowflake to deconstruct.
   * @param epoch The epoch to use when deconstructing.
   */
  static deconstruct(snowflake: snowflake, epoch?: number): DeconstructedSnowflake;

  /**
   * Generates a new snowflake.
   *
   * @param options The options to use when generating a snowflake.
   */
  static generate({
    epoch,
    timestamp,
  }?: GenerateSnowflakeOptions): snowflake;
}

/**
 * A Twitter snowflake, except the default epoch is 2015-01-01T00:00:00.000Z
 *
 * ```
 * If we have a snowflake '266241948824764416' we can represent it as binary:
 *
 * 64                                          22     17     12          0
 *  000000111011000111100001101001000101000000  00001  00000  000000000000
 *           number of ms since epoch           worker  pid    increment
 * ```
 */
export type snowflake = string;

export interface GenerateSnowflakeOptions {
  timestamp?: Date | number;
  epoch?: Date | number;
}

export interface DeconstructedSnowflake {
  binary: string;
  timestamp: number;
  workerId: number;
  processId: number;
  increment: number;
}

export class Collection<K, V> extends Map<K, V> {
  ["constructor"]: typeof Collection;

  /**
   *
   * Creates a collection from an array of tuples or object.
   *
   * @param {Tuple[] | Dictionary} tupleArrayOrObject The tuple array or dictionary.
   * @returns {Collection}
   */
  static from<K, V>(tupleArrayOrObject: Dictionary<V> | Tuple<K, V>[]): Collection<K, V>;
  /**
   * Creates a collection from an array of values and the keys are the indexes.
   *
   * @param {Array} values The array of values.
   * @returns {Collection}
   */
  static from<V>(values: V[]): Collection<number, V>;

  /**
   * Returns the first entry in this collection.
   *
   * @returns {?any}
   */
  first(): Tuple<K, V> | null;
  /**
   * Returns an array of entries at the start of this collection.
   *
   * @param {number} amount The amount of values.
   * @returns {any[]}
   */
  first(amount: number): Tuple<K, V>[];

  /**
   * Returns the last entry in this collection.
   *
   * @returns {?any}
   */
  last(): Tuple<K, V> | null;
  /**
   *
   * Returns an array of entries at the end of this collection.
   * @param {number} amount The amount of entries.
   * @returns {any[]}
   */
  last(amount: number): Tuple<K, V>[];

  /**
   * Get an array of all values in this collection.
   * @returns {any[]}
   */
  array(): V[];

  /**
   * Tests whether or not an entry in this collection meets the provided predicate.
   *
   * @param {function} predicate A predicate that tests all entries.
   * @param {any} [thisArg] An optional binding for the predicate function.
   * @returns {boolean}
   */
  some(predicate: (value: V, key: K, col: this) => unknown, thisArg?: unknown): boolean;

  /**
   * Creates a new collection with the items within the provided range.
   *
   * @param {number} [from] Where to stop.
   * @param {number} [end] Where to end.
   * @returns {Collection}
   */
  slice(from?: number, end?: number): Collection<K, V>;

  /**
   * Collection#forEach but it returns the collection instead of nothing.
   *
   * @param {function} fn The function to be ran on all entries.
   * @param {any} [thisArg] An optional binding for the fn parameter.
   * @returns {Collection}
   */
  each(fn: (value: V, key: K, col: this) => unknown, thisArg?: unknown): this;

  /**
   * Computes a value if it's absent in this collection.
   * @param {any} key The key.
   * @param {any} value The value to use if nothing is found.
   * @returns {any}
   */
  ensure(key: K, value: ((key: K) => V) | V): V;

  /**
   * Get a random value from this collection.
   *
   * @returns {any}
   */
  random(): V;

  /**
   * Get a random key from this collection.
   *
   * @returns {any}
   */
  randomKey(): K;

  /**
   * Get random entry from this collection.
   *
   * @returns {Tuple}
   */
  randomEntry(): Tuple<K, V>;

  /**
   * Sweeps entries from the collection.
   *
   * @param {function} fn The predicate.
   * @param {any} [thisArg] Optional binding for the predicate.
   * @returns {number}
   */
  sweep(fn: (value: V, key: K, col: this) => boolean, thisArg?: unknown): number;

  /**
   * Finds a value using a predicate from this collection
   *
   * @param {function} fn Function used to find the value.
   * @param {any} [thisArg] Optional binding to use.
   * @returns {?any}
   */
  find(fn: (value: V, key: K, col: this) => boolean, thisArg?: unknown): V | null;

  /**
   * Reduces this collection down into a single value.
   *
   * @param {function} fn The function used to reduce this collection.
   * @param {any} acc The accumulator.
   * @param {any} [thisArg] Optional binding for the reducer function.
   * @returns {any}
   */
  reduce<A>(fn: (acc: A, value: V, key: K, col: this) => A, acc: A, thisArg?: unknown): A;

  /**
   * Partition this collection. First collection are the entries that returned true, second collection are the entries that returned false.
   *
   * @param {function} predicate The predicate function.
   * @param {any} [thisArg] Optional binding for the predicate.
   * @returns {[Collection, Collection]}
   */
  partition(predicate: (value: V, key: K, col: this) => boolean, thisArg?: unknown): Tuple<Collection<K, V>, Collection<K, V>>;

  /**
   * Returns a filtered collection based on the provided predicate.
   *
   * @param {function} fn The predicate used to determine whether or not an entry can be passed to the new collection.
   * @param {any} [thisArg] Optional binding for the predicate.
   * @returns {Collection}
   */
  filter(fn: (value: V, key: K, col: this) => boolean, thisArg?: unknown): Collection<K, V>;

  /**
   * Maps this collection into an array. Array#map equivalent.
   *
   * @param {function} fn Function used to map values to an array.
   * @param {any} [thisArg] Optional binding for the map function.
   * @returns {any[]}
   */
  map<T>(fn: (value: V, key: K, col: this) => T, thisArg?: unknown): T[];

  /**
   * Sorts the entries in-place in this collection.
   *
   * @param {function} compareFunction Function to determine how this collection should be sorted.
   * @returns {Collection}
   */
  sort(compareFunction?: (firstValue: V, secondValue: V, firstKey?: K, secondKey?: K) => number): this;

  /**
   * Sorts entries in a new collection
   *
   * @param {function} compareFunction Function to determine how the resulting collection should be sorted
   * @returns {Collection}
   */
  sorted(compareFunction?: (firstValue: V, secondValue: V, firstKey?: K, secondKey?: K) => number): Collection<K, V>;

  /**
   * Returns a clone of this collection.
   *
   * @returns {Collection}
   */
  clone(): Collection<K, V>;

  /**
   * Get the string representation of this collection.
   *
   * @returns {string}
   */
  toString(): string;
}

export const SUBSCRIPTIONS: unique symbol;
export const SUBSCRIPTIONS_LIMIT: unique symbol;

/**
 * Handles event-related logic, implements {@link EventEmitterLike} interface for compatibility reasons.
 */
export class EventFlow<M extends SubscriptionMap = empty> implements EventEmitterLike {
  /**
   * The default number of subscriptions allowed for a single event.
   * @type {number}
   */
  static DEFAULT_SUBSCRIPTION_LIMIT: number;
  /**
   * Map of events and their subscriptions.
   *
   * @protected
   */
  protected [SUBSCRIPTIONS]: Map<event, SubscriptionMethod<any>[]>;
  /**
   * The total number of subscriptions allowed for a single event.
   *
   * @protected
   */
  protected [SUBSCRIPTIONS_LIMIT]: number;

  /**
   * Returns the total number of subscriptions for a single event.
   *
   * @returns number of subscriptions that can be added for a single event.
   */
  get subscriptionLimit(): number;
  /**
   * Sets the subscription limit to {@param newLimit}.
   *
   * @param newLimit The new subscription limit; or -1 for unlimited, however this is not recommended under any circumstances.
   */
  set subscriptionLimit(newLimit: number);

  /**
   * Sends all supplied args to each subscription for the supplied event.
   *
   * @param event The event
   * @param args The arguments to send.
   *
   * @returns {[ number, number ]}, where idx 0 is the number of successful sends and idx 1 is the total number of sends; successful or not.
   */
  send<E extends keyof M>(event: E, ...args: M[E]): [ sent: number, total: number ];

  /**
   * Subscribes a function to the supplied event.
   *
   * @param event The event to subscribe to.
   * @param func The function that will be called whenever {@param event} is received.
   */
  subscribe<E extends keyof M>(event: E, func: SubscriptionMethod<M[E]>): this;

  /**
   * Removes the provided {@param func} from the event subscriptions.
   *
   * @param event Event name
   * @param func The function to remove.
   */
  unsubscribe<E extends keyof M>(event: E, func: SubscriptionMethod<M[E]>): boolean;

  /**
   * Returns the number of subscriptions for {@param event}
   *
   * @param event Event name
   *
   * @returns {number} of subscriptions
   */
  getSubscriptionCount(event: keyof M): number;

  /**
   * Get all subscriptions for the supplied event name.
   *
   * @param event Event name
   */
  getSubscriptions<E extends keyof M>(event: E): SubscriptionMethod<M[E]>[];

  emit<E extends keyof M>(event: E, ...args: M[E]): boolean;

  addListener<E extends keyof M>(event: E, listener: SubscriptionMethod<M[E]>): any;

  removeListener<E extends keyof M>(event: E, listener: SubscriptionMethod<M[E]>): any;
}

export class SubscriptionLimitReached extends Error {
  /**
   * The event that had reached the subscription limit.
   * @type {event}
   */
  readonly event: event;
  /**
   * The subscription limit that was reached.
   * @type {number}
   */
  readonly limit: number;

  /**
   * @param event Event name.
   * @param limit Configured subscription limit.
   */
  constructor(event: event, limit: number);
}

type empty = SubscriptionMap<Dictionary>;
type event = symbol | string;
type customEvents = {
  "flow.error": [ error: Error, eventName: event, args: Array<any> ];
  "flow.warn": [ message: string ];
};
export type SubscriptionMethod<A extends any[] = any[]> = (...args: A) => void;
export type SubscriptionMap<T extends Record<event, SubscriptionMethod> = empty> = T & customEvents;

export type Tuple<A = any, B = any> = [ A, B ];
export type Dictionary<V = any, K extends PropertyKey = string> = Record<K, V>;
export type Class<T = any> = {
  new(...args: any[]): T;
};

/**
 * Used for compatibility between different types of event emitters.
 */
export interface EventEmitterLike {
  emit(event: string, ...args: any[]): boolean | void;

  addListener(event: string, listener: (...args: any[]) => void): EventEmitterLike | any;

  removeListener(event: string, listener: (...args: any[]) => void): EventEmitterLike | any;
}

export namespace Scheduled {
  /**
   * All scheduled intervals.
   */
  const INTERVALS: Set<NodeJS.Timeout>;
  /**
   * All scheduled timeouts.
   */
  const TIMEOUTS: Set<NodeJS.Timeout>;

  /**
   * Disposes of all intervals in {@link INTERVALS}
   *
   * @returns {number}
   */
  function clearIntervals(): number;

  /**
   * Disposes of each scheduled timeout in {@link TIMEOUTS}.
   *
   * @returns {number} The number of intervals that were disposed of.
   */
  function clearTimeouts(): number;

  /**
   * Disposes of all timeouts and intervals
   *
   * @see TIMEOUTS
   * @see INTERVALS
   *
   * @returns {Array} where index 0 is the number of cleared timeouts and index 1 is the number of cleared intervals.
   */
  function clear(): [ timeouts: number, intervals: number ];
}

/**
 * Creates a new {@link Interval}
 *
 * @param delay Delay between each execution
 * @param block The block to execute
 * @param args Arguments to pass
 */
export function createInterval(delay: number, block: Task, ...args: any[]): Interval;

/**
 * Creates a new {@link Timeout}
 *
 * @param delay Delay until execution
 * @param block The block to execute.
 * @param args Arguments to pass.
 */
export function createTimeout(delay: number, block: Task, ...args: any[]): Timeout;

export class Interval extends TaskScheduler {
  /**
   * Starts executing the configured task every `delay` milliseconds
   *
   * @param delay The delay between each execution.
   * @param args The arguments to pass.
   */
  start(delay: number, ...args: any[]): Interval;

  /**
   * Disposes of this interval.
   */
  dispose(): void;
}

export class Timeout extends TaskScheduler {
  /**
   * Executes the configured task in x milliseconds..
   *
   * @param delay The amount of time to wait.
   * @param args The arguments to pass.
   */
  start(delay: number, ...args: any[]): Timeout;

  /**
   * Disposes of this Timeout.
   */
  dispose(): void;
}

/**
 * Determines whether a value in an object.
 *
 * @param input The value to test
 */
export function isObject(input: unknown): input is Dictionary;

/**
 * Merges objects into one.
 *
 * @param {Dictionary} objects The objects to merge.
 */
export function mergeObject<O extends Record<PropertyKey, any> = Record<PropertyKey, any>>(...objects: Partial<O>[]): O;

/**
 * Used when the library is unsure whether a package has been installed.
 *
 * @param name The package name.
 */
export function safeRequire<T>(name: string): T | undefined;

export abstract class TaskScheduler {
  /**
   * The NodeJS timeout ref.
   */
  ref?: NodeJS.Timeout;
  /**
   * The provided task to execute.
   * @protected
   */
  protected _task: Task;

  /**
   * @param task The provided task.
   */
  constructor(task: Task);

  /**
   * Start's this scheduled task.
   *
   * @param delay The delay in which to execute this task.
   * @param args The arguments to pass.
   */
  abstract start(delay: number, ...args: any[]): TaskScheduler;

  /**
   * Cancels this Scheduled task.
   */
  abstract dispose(): void;
}

export type Task = (...args: any[]) => void;

